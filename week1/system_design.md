## Дизайн ML системы - Интернет-магазин с встроенной рекомендательной системой
 
> ## Термины и пояснения
> - Итерация - это все работы, которые совершаются до старта очередного пилота  
> - БТ - бизнес-требования 
> - EDA - Exploratory Data Analysis - исследовательский анализ данных
> - Продукт - приложение интернет-магазина.
> - Модель - модель машинного обучения, рекомендательная система.
> - Пилот - результат разработки текущей итерации.

### 1. Цели и предпосылки 
#### 1.1. Зачем идем в разработку продукта?  

- Бизнес-цель - увеличить выручку, конверсию в заказ, средний чек и частоту покупок путем релевантных персонализированных рекомендаций. 
- Почему станет лучше, чем сейчас, от использования ML - увеличение конверсии, среднего чека и частоты покупок ведет к увеличению прибыли, снижению среднего срока хранения товара на складе. Также это решение упростит выбор покупателя в приложении: при достаточно хороших рекомендациях выбор будет осуществляться быстрее, при этом товары будут действительно нравиться покупателю.

### **Критерии успеха:**
Мы будем смотреть сразу на несколько метрик для 1) формирования всесторонней оценки работы модели 2) доказательства состоятельности работы модели заказчикам:
1. NDCG@10 - используем для оценки качества ранжирования модели

   $NDCG@k =\frac{DCG_{k}}{IDCG_{k}}$,
   
   $DCG_{k} = \displaystyle\sum_{i=1}^{k} \frac{rel_{i}}{\log_{2}(i+1)},$
   $IDCG_{k}$ - максимальное (I — ideal) значение $DCG_{k}$

   $rel_{i}$ - релевантность $i$-той позиции (если не релевантен - 0)

   
2. Precision@10 - используем для оценки качества рекомендаций

   $Precision@K = \frac{\displaystyle\sum_{j=1}^{K} \mathbb{I}_{ij}}{K}$
   
   $\mathbb{I}_{ij}$ - индикаторная функция, показывающая, что пользователь $i$ провзаимодействовал с объектом $j$

3. Serendipity - используем для оценки новизны и релевантности контента для пользователя
   
   $Serendipity =\frac{1}{|R|} \sum_{i \in R} \max \left( P_i - P^{U}_i , 0 \right) \cdot rel_i$, 
   
   $P_i = \frac{|I| + 1 - rank_i}{|I|}; \, P^{U}_i = \frac{|I| + 1 - rank^{U}_i}{|I|}$

   $P_i, P^{U}_i$ - 'вероятности' порекомендовать товар i пользователю и 'произвольному' пользователю соответственно

   $rank_{i}$ - ранг товара i в рекомендациях пользователю

   $rank^{U}_i$ - ранг товара i в рекомендациях 'произвольному' пользователю

   $rel_{i}$ - релевантность $i$-той позиции (если не релевантен - 0)
   
4. Money_precision@10 - используем для приближения выручки*:
    
    $Money Precision@10 = \frac{\displaystyle\sum_{j=1}^{K} \mathbb{I}_{ij} \times Value_j}{K \times Value_j} $
    
    $\mathbb{I}_{ij}$ - индикаторная функция, показывающая, что пользователь $i$ провзаимодействовал с объектом $j$
    
    $Value_{j}$ - стоимость товара $j$

   ______________________
   
    \* Выручка = Средний чек * кол-во покупок = Средний чек * (число юзеров * конверсия из захода на сайт в заказ) = Число юзеров * (Средний чек * конверсия из захода на сайт в заказ).
      
    Рекомендательная система влияет только на (Средний чек * конверсия из захода на сайт в заказ). (Средний чек * конверсия из захода на сайт в заказ) = Money_precision

 ______________________
#### 1.2. Бизнес-требования и ограничения  

- Бизнес-процесс пилота - модель будет встроена в существующую экосистему продукта для улучшения показателей продаж и удовлетворенности покупателей. Раз в сутки (уточнить) необходимо для каждого пользователя с помощью модели подготавливать список рекомендаций и отображать в приложении.
- Бизнес-ограничения - запрос должен обрабатываться не более 3х секунд.
- Успешная модель - модель будет успешной, если она предлагает на должном уровне такие товары, которые будут выгодны интересны клиенту.
- Среда - разработка на локальных мощностях.
- Стэк-технологии - Python, PySpark, Flask, Docker 
- Данные - Используются реальные замаскированные данные одного из действующих маркетплейсов. Данные были собраны по определенному временому срезу (c 2023-07-31 по 2023-08-13) и помещены в csv-файл.
- Что мы ожидаем от конкретной итерации - веб-приложение онлайн магазина с API модели рекомендательной системы.
    - Неделя 1. Подготовка ML System Design
    - Неделя 2. Описание архитектуры продукта по нотации C4. EDA.
    - Неделя 3. Формирование обучающей выборки, разработка валидации. Разработка baseline, реализация.
    - Неделя 4. Оценка решения, оптимизация алгоритма. Разработка веб-приложения магазина.
    - Неделя 5. Организация model-serving и процесса переобучения алгоритма. Итоговая презентация пилота.

- Исполнители - Анна Кобякова, Даниил Иванов

#### 1.3. Что входит в скоуп проекта/итерации, что не входит   

- На закрытие каких БТ подписываемся в данной итерации - достигнуть необходимую точность прогноза и скорость обработки запроса.
- Что не будет закрыто - увеличение всех бизнес метрик, поскольку решение не будет встроено в продукт, их невозможно измерить.
- Описание результата с точки зрения качества кода и воспроизводимости решения - для работы с рекомендательной системой будет реализовано непубличное API и веб интерфейс для тестирования.
- Описание планируемого технического долга (что оставляем для дальнейшей продуктивизации) - доработка модели относительно качества рекомендаций, интеграция результатов работы модели в продукт.

#### 1.4. Предпосылки решения  

- В качестве входных данных модель получает историю покупок пользователя.
- Горизонтом прогноза является ранжированное множество рекомендуемых товаров.

### 2. Методология   

#### 2.1. Постановка задачи  

Разработка рекомендательной системы со встроенной моделью ранжирования результата на основе прошлых покупок пользователя.

#### 2.2. Блок-схема решения  

- [Блок-схема](https://github.com/AnnchenK/recsys/blob/main/week1/scheme_recsys.drawio.png) для бейзлайна и основного MVP с ключевыми этапами решения задачи. 

#### 2.3. Этапы решения задачи.  

Этап 1  - Сбор и обработка данных. Проведение EDA и feature engineering.
  
Скачиваем данные пользовательской активности (заказов) из csv-файла в тетрадь Jupyter Notebook. При работе проверяем заполненность и качество данных. Убираем крайне малозаполненные данные или малодостоверные, заполняем пропуски и меняем тип данных. По возможности создаём новые фичи. По итогу количественные признаки должны быть количественными, качественные качественными. 

| Название данных  | Есть ли данные в компании (если да, название источника/витрин) | Требуемый ресурс для получения данных (какие роли нужны) | Проверено ли качество данных (да, нет) |
| ------------- | ------------- | ------------- | ------------- |
| platform | csv-файл  | DS | - | 
| utc_event_time | csv-файл | DS | - |
| utc_event_date | csv-файл | DS | - |
| user_id | csv-файл | DS | - |
| event_type | csv-файл | DS | - |
| ecom.price100 | csv-файл | DS | - |
| ecom.qty | csv-файл | DS | - |
| ecom.nm | csv-файл | DS | - |

Общие требования к данным:

- Данные есть для полной базы клиентов (всех строчек csv-файла), процент пропусков < 5%

|**Название данных**|**Требования**|
| :-: | :-: |
|0| <p>- 0</p><p>- 0</p><p>- 0</p><p>- 0</p>|

Этап 2  - Подготовка к обучению.

- Данные делятся в отношении 90 на 10 на global train и global validation выборки по временному критерию (столбец `utc_event_date`).
- Для обучения и валидации first-stage модели global train будет делится 80/20 на local train и local validation соответственно.
- Для обучения и валидации second-stage модели global train будет делится 80/20 на local train и local validation соответственно.

Этап 3  - Создание моделей.
- 
  **Baseline**
Бэйзлайн – рекомендация наиболее интересных товаров пользователю исходя из наибольшего фокуса его группы принадлежности. Это главный ориентир при сравнении основной модели. Простая рекомендация – кластеризация клиентов, рассчёт агрегированных метрик по товарам, вывод в рекомендации топ k товаров.

Метрики бейзлайна вычисляются на данном этапе, после сбора данных. Метрики:
- Основная метрика – 00000.
- Дополнительная метрика – 00000

Риски этапа: 
 
- Некорректный выбор метрики из-за дисбаланса класса. Последует замена метрики на более корректную.
- Некорректный выбор фичей. Последует замена метрики на более корректную.
- Некорректная кластеризация клиентов. Последует улучшение/изменение алгоритма разбиения.

  **MVP**

MVP - ...

Метрики MVP вычисляются на данном этапе, после сбора данных. Метрики:
- Основная метрика – 00000.
- Дополнительная метрика – 00000

Использование 00000000 необходимо для:

Использование 00000000 необходимо для:

Необходимый результат этапа:

- Обучение модели с заданной точностью
- Получение набора признаков для отдельного MVP
- Общие для MVP задачи этапа


Риски этапа: 
 
- Некорректный выбор метрики из-за дисбаланса класса. Последует замена метрики на более корректную.
- Некорректный выбор фичей. Последует замена метрики на более корректную.
- Некорректная кластеризация клиентов. Последует улучшение/изменение алгоритма разбиения.

  
Этап 4  - Анализ результатов. Проверка значимости признаков.

Результат этапа:

- Оценка влияния различных факторов, сравнение их с бизнес-логикой
- Проверка отсутствия переобучения моделей
- Проверка на соблюдение моделью бизнес логики


При наличии дисбаланса в значимости факторов будет произведено переобучение моделей и/или дополнительный feature engineering.

Главные риски этапа: несогласуемость её с бизнес-логикой. В этом случае происходит возврат к 3 этапу в 2.3.

Этап 5 - Разработка веб-приложения магазина
Напишем backend и fronend для тестового маркетплейса.

Этап 6 - Организация model-serving и процесса переобучения алгоритма. Итоговая презентация пилота.
Пропишем связи веб-прилежения с API моделью

### 3. Подготовка пилота  
  
#### 3.1. Способ оценки пилота  
  
- Оценивается в соответствии с критериями успешности проекта.
  
#### 3.2. Что считаем успешным пилотом  
  
Общие с критериями успешности проекта.
  
